  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    if (!file.type.startsWith('image/')) {
      toast.error('Please select an image file')
      return
    }

    if (file.size > 10 * 1024 * 1024) {
      toast.error('Image must be smaller than 10MB')
      return
    }

    setIsUploadingImage(true)

    try {
      // Compress the image before uploading
      // Base64 encoding increases size by ~33%, so we target smaller compressed size
      const compressedFile = await imageCompression(file, {
        maxSizeMB: 0.05,             // Max 50KB (becomes ~67KB after base64)
        maxWidthOrHeight: 1024,      // 1024px is plenty for profile pictures
        initialQuality: 0.7,         // 70% quality - good balance
        useWebWorker: true,
      })

      console.log('Original file size:', (file.size / 1024).toFixed(2), 'KB')
      console.log('Compressed file size:', (compressedFile.size / 1024).toFixed(2), 'KB')
      console.log('Estimated base64 size:', ((compressedFile.size * 1.33) / 1024).toFixed(2), 'KB')

      const reader = new FileReader()
      reader.onloadend = async () => {
        const base64String = reader.result as string
        try {
          const response = await userAPI.updateProfilePicture({
            profileImage: base64String,
          })
          if (response.success && response.data) {
            updateLocalUser(response.data.user as UserData)
            toast.success('Profile picture updated!')
          }
        } catch (error: any) {
          toast.error(error.response?.data?.message || 'Failed to upload image')
        } finally {
          setIsUploadingImage(false)
        }
      }
      reader.onerror = () => {
        toast.error('Failed to read file')
        setIsUploadingImage(false)
      }
      reader.readAsDataURL(compressedFile)
    } catch (error) {
      console.error('Image upload error:', error)
      toast.error('Failed to compress image')
      setIsUploadingImage(false)
    }
  }
